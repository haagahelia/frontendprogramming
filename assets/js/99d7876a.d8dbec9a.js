"use strict";(self.webpackChunkfrontendcourse=self.webpackChunkfrontendcourse||[]).push([[8366],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(96540);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},79806:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"react-basics/userinput","title":"User Input","description":"In this section, you will learn how to read user input in React components","source":"@site/docs/react-basics/userinput.md","sourceDirName":"react-basics","slug":"/react-basics/userinput","permalink":"/frontendprogramming/docs/react-basics/userinput","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"User Input","description":"In this section, you will learn how to read user input in React components","sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"State","permalink":"/frontendprogramming/docs/react-basics/state"},"next":{"title":"React Project","permalink":"/frontendprogramming/docs/category/react-project"}}');var a=t(74848),r=t(28453);const o={title:"User Input",description:"In this section, you will learn how to read user input in React components",sidebar_position:8},i=void 0,l={},c=[{value:"Reading user input",id:"reading-user-input",level:3},{value:"Multiple input elements",id:"multiple-input-elements",level:3},{value:"Forms",id:"forms",level:3},{value:"Further reading",id:"further-reading",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h3,{id:"reading-user-input",children:"Reading user input"}),"\n",(0,a.jsx)(n.p,{children:"In this part, you will learn how to read user input in React components"}),"\n",(0,a.jsxs)(n.p,{children:["You can use input element\u2019s ",(0,a.jsx)(n.code,{children:"onChange"})," event attribute and ",(0,a.jsx)(n.code,{children:"value"})," attribute to read user input into the state of the component."]}),"\n",(0,a.jsxs)(n.p,{children:["We need a ",(0,a.jsx)(n.code,{children:"state"})," to manage the value of the input in a controlled component. In controlled component the values are controlled by the ",(0,a.jsx)(n.code,{children:"state"})," of a React component."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const [name, setName] = useState("");\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"onChange"})," handler is invoked at every keystroke and it calls ",(0,a.jsx)(n.code,{children:"handleChange"})," function that saves user input to react state. As the state changes, react updates the state value back to the input element by setting the ",(0,a.jsx)(n.code,{children:"value"})," attribute of the element."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'<input placeholder="Name" value={name} onChange={handleChange} />\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Next, create ",(0,a.jsx)(n.code,{children:"handleChange"})," function to update state. The ",(0,a.jsx)(n.code,{children:"event.target.value"})," is now the value from the input element that causes the ",(0,a.jsx)(n.code,{children:"onChange"}),"  DOM event."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"const handleChange = (event) => {\n  setName(event.target.value);\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now, you can see the following TypeScript error in ",(0,a.jsx)(n.code,{children:"event"})," parameter in the ",(0,a.jsx)(n.code,{children:"handleChange"})," function: ",(0,a.jsx)(n.em,{children:"error TS7006: Parameter 'event' implicitly has an 'any' type."}),". We have to define type for the ",(0,a.jsx)(n.code,{children:"event"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n  setName(event.target.value); \n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"React.ChangeEvent"})," is a generic type provided by React to represent events triggered by form elements (input, select, textarea). The generic type ",(0,a.jsx)(n.code,{children:"<HTMLInputElement> "}),"specifies that this event is for an ",(0,a.jsx)(n.code,{children:"input"})," element."]}),"\n",(0,a.jsx)(n.p,{children:"The following example prints a text on the screen, that you type to the input element:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"function HelloName() {\n  const [name, setName] = useState('');\n  \n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setName(event.target.value); \n  };\n  \n  return (\n    <>\n      <h3>Hello {name}</h3>\n      <input \n        placeholder=\"Name\" \n        value={name} \n        onChange={handleChange} />\n    </>\n   );\n}\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:["In this material we are using ",(0,a.jsx)(n.strong,{children:"controlled components"}),". A controlled component is a form element, such as an input field, whose value is controlled by the state of a React component. This means that the value of the input element is stored in the component's state, and any changes to the input element are reflected in the component's state. It easy to manipulate and validate user input when using controlled components."]}),(0,a.jsxs)(n.p,{children:["You can also use an ",(0,a.jsx)(n.strong,{children:"uncontrolled components"})," to handle form elements. In this case, React doesn't manage the value of an uncontrolled component, and you have to rely on traditional DOM methods to access and manipulate the input's value. Uncontrolled component can be used, if you have a simple use case that doesn't require managing the input value through React state."]})]}),"\n",(0,a.jsx)(n.h3,{id:"multiple-input-elements",children:"Multiple input elements"}),"\n",(0,a.jsxs)(n.p,{children:["If you have multiple input elements it is not good idea to create own ",(0,a.jsx)(n.code,{children:"onChange"})," listener function to all input elements. We can handle all input fields using one common ",(0,a.jsx)(n.code,{children:"onChange"})," listener function. To achieve that we will also use ",(0,a.jsx)(n.code,{children:"name"})," attribute of the input elements. The value of the ",(0,a.jsx)(n.code,{children:"name"})," attribute should be exactly the same than name of the state where we store the value of the input element."]}),"\n",(0,a.jsxs)(n.p,{children:["In the following example, we have the state called ",(0,a.jsx)(n.code,{children:"person"})," and it is an object that has two attributes ",(0,a.jsx)(n.code,{children:"firstName"})," and ",(0,a.jsx)(n.code,{children:"lastName"}),". First, we create a type for our state:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"type Person = {\n  firstName: string;\n  lastName: string;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Then, declare ",(0,a.jsx)(n.code,{children:"person"})," state:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const [person, setPerson] = useState<Person>({firstName: '', lastName: ''});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To update only the ",(0,a.jsx)(n.code,{children:"firstName"})," or ",(0,a.jsx)(n.code,{children:"lastName"})," property in the state object, you can use the spread operator (",(0,a.jsx)(n.code,{children:"..."}),"). The syntax is as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"setPerson({ ...person, lastName: 'Johnson' });\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Add ",(0,a.jsx)(n.code,{children:"name"})," attributes to the input elements and set their values match the corresponding state object properties (",(0,a.jsx)(n.code,{children:"firstName"})," and ",(0,a.jsx)(n.code,{children:"lastName"}),")."]}),"\n",(0,a.jsxs)(n.p,{children:["Set the ",(0,a.jsx)(n.code,{children:"value"})," attributes to reference the state object properties (",(0,a.jsx)(n.code,{children:"person.firstName"})," and ",(0,a.jsx)(n.code,{children:"person.lastName"}),")."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<input \n  name="firstName"\n  value={person.firstName} \n  onChange={handleChange} />\n<input \n  name="lastName"\n  value={person.lastName} \n  onChange={handleChange} />\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now, the both input elements has same function called if the ",(0,a.jsx)(n.code,{children:"onChange"})," DOM event is invoked. Then, we can use ",(0,a.jsx)(n.code,{children:"event.target.name"})," and ",(0,a.jsx)(n.code,{children:"event.target.value"})," to save input element\u2019s value to correct state. See the syntax below:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n  setName({ ...name, [event.target.name]: event.target.value});\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now if the user types something to firstName input element, the ",(0,a.jsx)(n.code,{children:"event.target.name"})," is firstName and ",(0,a.jsx)(n.code,{children:"event.target.value"})," is a value that user has entered to the firstName input element."]}),"\n",(0,a.jsxs)(n.p,{children:["Alternatively, you can define an event handler directly on the ",(0,a.jsx)(n.code,{children:"input"})," element. The ",(0,a.jsx)(n.code,{children:"input"})," elements would look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"<input \n  value={person.firstName} \n  onChange={ event => setPerson({...person, firstName: event.target.value}) } />\n<input \n  value={person.lastName} \n  onChange={ event => setPerson({...person, lastName: event.target.value}) } />\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now, you don't need to explicitly define the event type, as TypeScript can infer it automatically. The complete source code would look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\n\ntype Person = {\n  firstName: string;\n  lastName: string;\n}\n\nfunction App() {\n  const [person, setPerson] = useState<Person>({firstName: '', lastName: ''});\n \n  return (\n    <>\n      <h3>Hello {person.firstName} {person.lastName}</h3>\n      <label>\n        First name:\n        <input \n          value={person.firstName} \n          onChange={ event => setPerson({...person, firstName: event.target.value}) } />\n      </label><br/>\n     <label>\n        Last name:\n        <input \n          value={person.lastName} \n          onChange={ event => setPerson({...person, lastName: event.target.value}) } />\n      </label>   \n    </>\n   );\n}\n\nexport default App\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Using a ",(0,a.jsx)(n.code,{children:"<label>"})," with an HTML ",(0,a.jsx)(n.code,{children:"<input>"})," is recommended for accessibility. Screen readers can identify the label and announce it to users. It also creates clickable area so that clicking on the label will focus the input field. That helps also when using the with smaller screen."]}),"\n",(0,a.jsx)(n.h3,{id:"forms",children:"Forms"}),"\n",(0,a.jsxs)(n.p,{children:["You can also use HTML ",(0,a.jsx)(n.code,{children:"form"})," element. Form handling is a little bit different with React. A HTML form will always navigate to another page when it is submitted but we want to avoid that. Common case is that we want to invoke javascript function that has access to form data after the submission."]}),"\n",(0,a.jsx)(n.p,{children:"If we use the form element:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-html",children:'<form onSubmit={handleSubmit}>\n  <input \n    name="message"\n    value={message}\n    onChange={handleChange} />\n  <input type="submit" value="Add"/>\n</form>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Now, if an user submits the form it invokes ",(0,a.jsx)(n.code,{children:"handleSubmit"})," function. In the ",(0,a.jsx)(n.code,{children:"handleSubmit"})," function, we have to first call ",(0,a.jsx)(n.code,{children:"event.preventDefault()"})," function. That function ignores the default behavior of the form and it will not be submitted."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n  event.preventDefault(); // ignores the default action \n  // Do something with form data\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"React.FormEvent"})," is a type provided by React to represent events triggered by form elements (",(0,a.jsx)(n.code,{children:"<HTMLFormElement>"})," in this case). It ensures type safety when working with form-related events like ",(0,a.jsx)(n.code,{children:"onSubmit"}),"."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"further-reading",children:"Further reading"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://react.dev/reference/react-dom/components/input",children:"https://react.dev/reference/react-dom/components/input"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);
"use strict";(self.webpackChunkfrontendcourse=self.webpackChunkfrontendcourse||[]).push([[1077],{1763:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/nasa1-1ce817c59ea892419047c44cbf749a0f.png"},4904:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/nasa2-259f28448effcda630bbfbc108141b0d.png"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},9489:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"networking/fetchexample","title":"Networking Example","description":"Before using a REST API, it\'s essential to read its documentation. This will help you understand how to make API calls and how the response payload looks like.","source":"@site/docs/networking/fetchexample.md","sourceDirName":"networking","slug":"/networking/fetchexample","permalink":"/frontendprogramming/docs/networking/fetchexample","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Networking Example","sidebar_label":"Nasa example","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Fetch","permalink":"/frontendprogramming/docs/networking/fetch"},"next":{"title":"User list example","permalink":"/frontendprogramming/docs/networking/listhandling"}}');var s=t(4848),i=t(8453);const r={title:"Networking Example",sidebar_label:"Nasa example",sidebar_position:4},o=void 0,d={},l=[{value:"NASA APOD API",id:"nasa-apod-api",level:3},{value:"Response",id:"response",level:4},{value:"State for response data",id:"state-for-response-data",level:4},{value:"Fetch",id:"fetch",level:4},{value:"Display data",id:"display-data",level:4},{value:"Further reading",id:"further-reading",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Before using a REST API, it's essential to read its documentation. This will help you understand how to make API calls and how the response payload looks like."}),"\n",(0,s.jsx)(n.h3,{id:"nasa-apod-api",children:"NASA APOD API"}),"\n",(0,s.jsxs)(n.p,{children:["The following example uses the ",(0,s.jsx)(n.strong,{children:"NASA APOD"})," API, that displays daily astronomy picture or video (",(0,s.jsx)(n.a,{href:"https://api.nasa.gov/",children:"https://api.nasa.gov/"}),"). The example sends a request to the NASA APOD API and displays the daily image and explanation that we receive in a response."]}),"\n",(0,s.jsxs)(n.p,{children:["Rest API can be called by using the following URL using the ",(0,s.jsx)(n.code,{children:"GET"})," method:\n",(0,s.jsx)(n.a,{href:"https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY",children:"https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY"})]}),"\n",(0,s.jsxs)(n.p,{children:["The response payload contains ",(0,s.jsx)(n.code,{children:"explanation"})," and ",(0,s.jsx)(n.code,{children:"url"})," properties. The ",(0,s.jsx)(n.code,{children:"media_type"})," property can be used to check if the daily media is video or image."]}),"\n",(0,s.jsx)(n.h4,{id:"response",children:"Response"}),"\n",(0,s.jsx)(n.p,{children:"The response payload looks like the image below:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Nasa API response",src:t(1763).A+"",width:"704",height:"487"})}),"\n",(0,s.jsx)(n.h4,{id:"state-for-response-data",children:"State for response data"}),"\n",(0,s.jsx)(n.p,{children:"We will create a React app that calls the NASA APOD API and displays the daily image and explanation. We need a state to store data from the response (image url, explanation, and type of media). Let's first define a type for our state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type ApodData = {\n  copyright: string;\n  date: string;\n  explanation: string;\n  media_type: string;\n  service_version: string;\n  title: string;\n  url: string;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The, we define a state where payload is stored:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// State to store payload\nconst [data, setData] = useState<ApodData | null>(null);\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Defining types is not strictly required in this case. However, using explicit types improves code readability for other developers (or even for your in the future). For instance, ",(0,s.jsx)(n.code,{children:"useState<ApodData>"})," clearly indicates the expected structure of the state. TypeScript will also alert you if you try to access a property that doesn't exist."]})}),"\n",(0,s.jsx)(n.h4,{id:"fetch",children:"Fetch"}),"\n",(0,s.jsxs)(n.p,{children:["The fetch API call is made inside the ",(0,s.jsx)(n.code,{children:"useEffect"})," hook, and the second argument is an empty array because we want to send requests only once after the first render."]}),"\n",(0,s.jsxs)(n.p,{children:["When the response arrives, the response data is saved to the ",(0,s.jsx)(n.code,{children:"data"})," state, and UI is re-rendered automatically by React."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"useEffect(() => {\n  fetch('https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY')\n  .then(response =>  { \n    if (!response.ok)\n      throw new Error(\"Error in fetch: \" + response.statusText);  \n    \n    return response.json();\n  })\n  .then(responseData => setData(responseData))\n  .catch(err => console.error(err))\n}, []);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"display-data",children:"Display data"}),"\n",(0,s.jsxs)(n.p,{children:["Then, we will use conditional rendering. We will check the ",(0,s.jsx)(n.code,{children:"media_type"})," and render either an image or video. We use the optional chaining (",(0,s.jsx)(n.code,{children:"?"}),") to safely access ",(0,s.jsx)(n.code,{children:"data"})," object that might be ",(0,s.jsx)(n.code,{children:"null"})," or ",(0,s.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'if (data?.media_type === "image") {\n  return (\n    <>\n      <p>Explanation: {data.explanation}</p>\n      <img alt="APOD image" src={data.url} />\n    </>\n  );\n}\nelse {\n  return (\n    <>\n      <p>Explanation: {data?.explanation}</p>\n      <iframe width="520" height="415" src={data?.url}></iframe>\n    </>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Or using inline conditional rendering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'return (\n  <>\n    <p>Explanation: {data?.explanation}</p>\n    { data?.media_type === \'video\' && <iframe width="520" height="415" src={data.url}></iframe> }          \n    { data?.media_type === \'image\' && <img  alt="APOD image" src={data.url} /> }\n  </>\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Nasa API example",src:t(4904).A+"",width:"683",height:"384"})}),"\n",(0,s.jsxs)(n.p,{children:["To show loading indicator, we can create a state to track the loading status. The intial value of the state is ",(0,s.jsx)(n.code,{children:"false"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const [loading, setLoading] = React.useState(false);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We update it's value to ",(0,s.jsx)(n.code,{children:"true"})," when the fetch starts. We then set it back to ",(0,s.jsx)(n.code,{children:"false"})," using the ",(0,s.jsx)(n.code,{children:"finally"})," statement, which executes whether the fetch succeeds or fails."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"React.useEffect(() => {\n  //highlight-next-line\n  setLoading(true);\n  fetch('https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY')\n    .then(response => { \n      if (!response.ok) throw new Error(\"Error in fetch: \" + response.statusText);  \n      return response.json();\n    })\n    .then(responseData => setData(responseData))\n    .catch(err => console.error(err))\n    //highlight-next-line\n    .finally(() => setLoading(false));\n}, []);\n"})}),"\n",(0,s.jsxs)(n.p,{children:['And we display text "Loading..." if the ',(0,s.jsx)(n.code,{children:"loading"})," state is ",(0,s.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'if  (loading) {\n  return <p>loading...</p>\n}\nelse {\n  return (\n    <>\n      <p>Explanation: {data?.explanation}</p>\n      { data?.media_type === \'video\' && <iframe width="520" height="415" src={data.url}></iframe> }          \n      { data?.media_type === \'image\' && <img  alt="APOD image" src={data.url} /> }\n    </>\n  );    \n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["In the NASA APOD example, we made a network request using the ",(0,s.jsx)(n.code,{children:"useEffect"})," hook because we wanted to display the APOD image once after the component is rendered the first time. When a request requires some user input, such as pressing a button, you can trigger the request within the button's ",(0,s.jsx)(n.code,{children:"onClick"})," event handler, and the ",(0,s.jsx)(n.code,{children:"useEffect"})," hook is not needed. You should avoid using unnecessary ",(0,s.jsx)(n.code,{children:"useEffect"}),"s as it increases the complexity of the component."]})}),"\n",(0,s.jsxs)(n.p,{children:["In proper React applications, you might use some data fetching library such as Tanstack Query or SWR. By using these, you can significantly enhance the performance, reliability, and maintainability of your React applications. They provide a lot of nice features such as data caching, automatic refetching, error handling etc. Read more about ",(0,s.jsx)(n.code,{children:"useEffect"})," alternatives in ",(0,s.jsx)(n.a,{href:"https://react.dev/reference/react/useEffect#what-are-good-alternatives-to-data-fetching-in-effects",children:"https://react.dev/reference/react/useEffect#what-are-good-alternatives-to-data-fetching-in-effects"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"further-reading",children:"Further reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tanstack Query"}),": ",(0,s.jsx)(n.em,{children:'"Tanstack Query (formerly React Query) is often described as the missing data-fetching library for React, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your React applications a breeze."'}),"\n",(0,s.jsx)(n.a,{href:"https://tanstack.com/query",children:"https://tanstack.com/query"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"SWR"})})," SWR (",(0,s.jsx)(n.a,{href:"https://swr.vercel.app/",children:"https://swr.vercel.app/"}),") is similar to Tanstack Query."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);